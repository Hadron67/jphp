package com.hadroncfy.jphp.jzend.compile;

import com.hadroncfy.jphp.jzend.types.Zval;

import java.io.PrintStream;
import java.util.*;


/**
 *
 * Created by cfy on 16-8-26.
 */
public class Class extends ZendClass {

    protected Map<String,Zval> consts = new HashMap<>();
    protected Map<String,ClassMember<Zval>> vars = new HashMap<>();
    protected Map<String,ClassMember<ZendMethod>> methods = new HashMap<>();

    private Routine autoGeneratedConstructor = null;

    private boolean hasUserDefinedConstructor = false;

    PreBindings preBindings = new PreBindings();

    protected Class(String name){
        cname = name;
    }

    @Override
    protected String getHeadName() {
        return "class";
    }

    @Override
    protected void addImplement(String cname) {
        preBindings.implementList.add(cname);
    }

    @Override
    protected void addExtends(String cname) {
        preBindings.parent = cname;
    }

    @Override
    protected void dump_self(Dumper dumper) {
        PrintStream ps = dumper.ps;
        ps.print(getHeadName() + " ");
        ps.print(cname);
        if(preBindings.parent != null){
            ps.print(" extends ");
            ps.print(preBindings.parent);
        }
        if(!preBindings.implementList.isEmpty()){
            ps.print(" implments ");
            for(String ename : preBindings.implementList){
                ps.print(ename);
                ps.print(",");

            }
        }
        if(!preBindings.useList.isEmpty()) {
            ps.println();
            ps.print("use ");
            for (String use : preBindings.useList) {
                ps.print(use);
                ps.print(",");
            }
            ps.print("{");
            if(!preBindings.traitAliasMap.isEmpty()){
                for(Map.Entry<String,TraitAlias> entry : preBindings.traitAliasMap.entrySet()){
                    ps.print(entry.getValue().toString());
                    ps.print(";");
                }
            }
            for(Map.Entry<String,TraitExcluder> entry : preBindings.traitExcluds.entrySet()){
                ps.print(entry.getValue().toString());
                ps.print(";");
            }
            ps.print("}");
        }
        ps.println();
        for(Map.Entry<String,Zval> entry : consts.entrySet()){
            ps.print("const ");
            ps.print(entry.getKey());
            ps.print(": ");
            ps.print(entry.getValue().dump());
            ps.println();
        }
        for(Map.Entry<String,ClassMember<Zval>> var : vars.entrySet()){
            ps.print(var.getValue().getHead());
            ps.print("$");
            ps.print(var.getKey());
            ps.print(" : ");
            ps.print(var.getValue().member.dump());
            ps.println();
        }
        for(Map.Entry<String,ClassMember<ZendMethod>> method : methods.entrySet()){
            ps.print(method.getValue().getHead());
            method.getValue().member.dump_self(dumper);
        }
        ps.println("===================================================");
    }

    protected void addConst(String cname,Zval value) throws RedeclareException {
        if(consts.get(cname) != null){
            throw new RedeclareException("Cannot redefine class constant " + this.cname +"::" + cname);
        }
        consts.put(cname,value);
    }

    @Override
    protected void addVar(String name,ClassMember<Zval> var) throws IllegalClassOperationException {
        vars.put(name,var);
    }

    @Override
    protected void addMethod(ClassMember<ZendMethod> func) throws RedeclareException, InvalidMethodException {
        MethodHead head = func.member.head;
        if(methods.get(func.member.getName()) != null){
            throw new RedeclareException("Cannot redeclare " + func.member.getFullName() + "()");
        }

        if(head.fname.equals("__call") && ( func.isStatic || func.access != Access.PUBLIC)){
            throw new InvalidMethodException("The magic method __call() must have public visibility and cannot be static");
        }
        else if(head.fname.equals("__callStatic") && ( !func.isStatic || func.access != Access.PUBLIC )){
            throw new InvalidMethodException("The magic method __callStatic() must have public visibility and be static");
        }
        else if(head.fname.equals("__get") && ( func.isStatic || func.access != Access.PUBLIC )){
            throw new InvalidMethodException("The magic method __get() must have public visibility and cannot be static");
        }
        else if(head.fname.equals("__set") && ( func.isStatic || func.access != Access.PUBLIC )){
            throw new InvalidMethodException("The magic method __set() must have public visibility and cannot be static");
        }
        else if(head.fname.equals("__unset") && ( func.isStatic || func.access != Access.PUBLIC )){
            throw new InvalidMethodException("The magic method __unset() must have public visibility and cannot be static");
        }
        else if(head.fname.equals("__isset") && ( func.isStatic || func.access != Access.PUBLIC )){
            throw new InvalidMethodException("The magic method __isset() must have public visibility and cannot be static");
        }
        else if(head.fname.equals("__toString") && ( func.isStatic || func.access != Access.PUBLIC )){
            throw new InvalidMethodException("The magic method __toString() must have public visibility and cannot be static");
        }


        methods.put(func.member.getName(),func);
        func.member.clazz = this;

    }

    @Override
    protected void addUse(String tname) throws IllegalClassOperationException {
        preBindings.useList.add(tname);
    }

    @Override
    protected void addAliasItem(TraitAlias alias) throws IllegalClassOperationException {
        preBindings.traitAliasMap.put(alias.methodName,alias);
    }

    @Override
    protected void addExcluder(TraitExcluder te) throws IllegalClassOperationException {
        preBindings.traitExcluds.put(te.methodName,te);
    }

    @Override
    protected boolean finishParsing() throws IllegalModifierException {
        //first,check if all the methods are implemented,i.e.,no abstract methods.
        String invalidMethods = null;
        int i = 0;
        for(Map.Entry<String,ClassMember<ZendMethod>> entry : methods.entrySet()){
            if(entry.getValue().member.isAbstract()){
                if(invalidMethods == null){
                    i++;
                    invalidMethods = entry.getValue().member.getFullName();
                }
                else {
                    invalidMethods += "," + entry.getValue().member.getFullName();
                    i++;
                }
            }
        }
        if(invalidMethods != null){
            throw new IllegalModifierException("Class " + getName() + " contains " + i + " abstract method and must therefore be declared abstract or implement the remaining methods (" + invalidMethods + ")");
        }
        //second,generate default constructor if needed.


        return true;
    }

    @Override
    public boolean isBind() {
        return false;
    }

    private class PreBindings{
        String parent = null;
        List<String> implementList = new ArrayList<>();
        List<String> useList = new ArrayList<>();
        Map<String,TraitAlias> traitAliasMap = new HashMap<>();
        Map<String,TraitExcluder> traitExcluds = new HashMap<>();
    }


}
